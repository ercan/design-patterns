#SINGLETON PATTERN#

	Singleton pattern restricts the instantiation of a class and ensures that
	only one instance of the class exists in JVM.

	- Private Constructor to restrict instantiation of the class from other classes.
	- Private static variable of the same class that is the only instance of the class.
	- Public static method that returns the instance of the class, this is the global
		access point for outer world to get instance of the singleton class.

	_JAVA_

		public class SingletonClass{

			private static SingletonClass instance;

			private SingletonClass(){}

			// "synchronized" keyword ensures that only one thread can call 
			// the getInstance method at the same time.
			public static synchronized SingletonClass getInstance(){
				if(instance == null)
					instance = new SingletonClass();
				return instance;
			}
		}

	_KOTLIN_

		// Singleton object can inherit another class.
		object Singleton{
    		init {
        		println("Singleton class invoked.")
    		}
			// Variables and functions in this scope are "static" member of the Singleton object.
			// Functions can take parameters and return objects.
    		var variableName = "I am Var"
    		fun printVarName(){
        		println(variableName)
    		}
		}

#FACTORY PATTERN#

	Factory pattern is used when we have a super class with multiple sub-classes
	and based on input, we need to return one of the sub-class. We can apply Singleton
	pattern on Factory class or make the factory method static.

	_JAVA_

		public abstract class Computer {
	
			public abstract String getRAM();
			public abstract String getHDD();
			public abstract String getCPU();
			
			@Override
			public String toString(){
				return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU();
			}
		}

		public class PC extends Computer {

			private String ram;
			private String hdd;
			private String cpu;
	
			public PC(String ram, String hdd, String cpu){
				this.ram=ram;
				this.hdd=hdd;
				this.cpu=cpu;
			}
			// getters & setters
		}

		public class Server extends Computer {
		
			private String ram;
			private String hdd;
			private String cpu;
	
			public Server(String ram, String hdd, String cpu){
			this.ram=ram;
			this.hdd=hdd;
			this.cpu=cpu;
			}
			// getters & setters
		}

		// getComputer method is the factory method that returns a Computer according to parameters.
		public class ComputerFactory {

			public static Computer getComputer(String type, String ram, String hdd, String cpu){
				if("PC".equalsIgnoreCase(type)) 
					return new PC(ram, hdd, cpu);
				else if("Server".equalsIgnoreCase(type)) 
					return new Server(ram, hdd, cpu);
				return null;
			}
		}

	_KOTLIN_

		abstract class Computer{
			abstract fun getRAM(): String
			abstract fun getHDD(): String
			abstract fun getCPU(): String

			override fun toString(): String{
				return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU()
			}
		}

		public class PC (var ram: String, var hdd: String, var cpu: String) : Computer(){
			override fun getRAM(): String{
				return ram
			}
			override fun getHDD(): String{
				return hdd
			}
			override fun getCPU(): String{
				return this.cpu
			}
			// and setters...
		}

		public class Server (var ram: String, var hdd: String, var cpu: String) : Computer(){
			override fun getRAM(): String{
				return ram
			}
			override fun getHDD(): String{
				return hdd
			}
			override fun getCPU(): String{
				return this.cpu
			}
			// and setters...
		}

		public class ComputerFactory{
			companion object{
				public fun getComputer(type: String, ram: String, hdd: String, cpu: String): Computer? = 
				when(type){
					"PC" -> PC(ram, hdd, cpu)
					"SERVER" -> Server(ram, hdd, cpu)
					else -> null
				}
			}
		}

#ABSTRACT FACTORY PATTERN#

	Abstract factory pattern is similar to Factory pattern but we get rid of if-else or when block
	in abstract factory pattern and we have a factory class for each sub-class. It is called 
	"the factory of factories".

	_JAVA_
		// For the same; PC, Server and Computer classes stay the same.
		public interface ComputerAbstractFactory {
			public Computer createComputer();
		}
		public class ComputerFactory {
			public static Computer getComputer(ComputerAbstractFactory factory){
				return factory.createComputer();
			}
		}
		Computer myPC = ComputerFactory.getComputer(new PCFactory(".."..".."))
		Computer myServer = ComputerFactory.getComputer(new ServerFactory(".."..".."))

	_KOTLIN_

		// For the same; PC, Server and Computer classes stay the same.
		public interface ComputerAbstractFactory{
    		abstract fun createComputer(): Computer
		}
		public class PCFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
			override fun createComputer(): Computer = PC(ram, hdd, cpu)
		}
		public class ServerFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
			override fun createComputer(): Computer = Server(ram, hdd, cpu)
		}
		public class ComputerFactory{
			companion object{
				public fun getComputer(computerAbstractFactory: ComputerAbstractFactory): Computer{
					return computerAbstractFactory.createComputer()
				}
			}
		}


