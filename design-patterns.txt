# SINGLETON PATTERN #

	Singleton pattern restricts the instantiation of a class and ensures that
	only one instance of the class exists in JVM.

	- Private Constructor to restrict instantiation of the class from other classes.
	- Private static variable of the same class that is the only instance of the class.
	- Public static method that returns the instance of the class, this is the global
		access point for outer world to get instance of the singleton class.

	_JAVA_

		public class SingletonClass{

			private static SingletonClass instance;

			private SingletonClass(){}

			// "synchronized" keyword ensures that only one thread can call 
			// the getInstance method at the same time.
			public static synchronized SingletonClass getInstance(){
				if(instance == null)
					instance = new SingletonClass();
				return instance;
			}
		}

	_KOTLIN_

		// Singleton object can inherit another class.
		object Singleton{
    		init {
        		println("Singleton class invoked.")
    		}
			// Variables and functions in this scope are "static" member of the Singleton object.
			// Functions can take parameters and return objects.
    		var variableName = "I am Var"
    		fun printVarName(){
        		println(variableName)
    		}
		}

# FACTORY PATTERN #

	Factory pattern is used when we have a super class with multiple sub-classes
	and based on input, we need to return one of the sub-class. We can apply Singleton
	pattern on Factory class or make the factory method static.

	_JAVA_

		public abstract class Computer {
	
			public abstract String getRAM();
			public abstract String getHDD();
			public abstract String getCPU();
			
			@Override
			public String toString(){
				return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU();
			}
		}

		public class PC extends Computer {

			private String ram;
			private String hdd;
			private String cpu;
	
			public PC(String ram, String hdd, String cpu){
				this.ram=ram;
				this.hdd=hdd;
				this.cpu=cpu;
			}
			// getters & setters
		}

		public class Server extends Computer {
		
			private String ram;
			private String hdd;
			private String cpu;
	
			public Server(String ram, String hdd, String cpu){
			this.ram=ram;
			this.hdd=hdd;
			this.cpu=cpu;
			}
			// getters & setters
		}

		// getComputer method is the factory method that returns a Computer according to parameters.
		public class ComputerFactory {

			public static Computer getComputer(String type, String ram, String hdd, String cpu){
				if("PC".equalsIgnoreCase(type)) 
					return new PC(ram, hdd, cpu);
				else if("Server".equalsIgnoreCase(type)) 
					return new Server(ram, hdd, cpu);
				return null;
			}
		}

	_KOTLIN_

		abstract class Computer{
			abstract fun getRAM(): String
			abstract fun getHDD(): String
			abstract fun getCPU(): String

			override fun toString(): String{
				return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU()
			}
		}

		public class PC (var ram: String, var hdd: String, var cpu: String) : Computer(){
			override fun getRAM(): String{
				return ram
			}
			override fun getHDD(): String{
				return hdd
			}
			override fun getCPU(): String{
				return this.cpu
			}
			// and setters...
		}

		public class Server (var ram: String, var hdd: String, var cpu: String) : Computer(){
			override fun getRAM(): String{
				return ram
			}
			override fun getHDD(): String{
				return hdd
			}
			override fun getCPU(): String{
				return this.cpu
			}
			// and setters...
		}

		public class ComputerFactory{
			companion object{
				public fun getComputer(type: String, ram: String, hdd: String, cpu: String): Computer? = 
				when(type){
					"PC" -> PC(ram, hdd, cpu)
					"SERVER" -> Server(ram, hdd, cpu)
					else -> null
				}
			}
		}

# ABSTRACT FACTORY PATTERN #

	Abstract factory pattern is similar to Factory pattern but we get rid of if-else or when block
	in abstract factory pattern and we have a factory class for each sub-class. It is called 
	"the factory of factories".

	_JAVA_
		// For the same; PC, Server and Computer classes stay the same.
		public interface ComputerAbstractFactory {
			public Computer createComputer();
		}
		public class ComputerFactory {
			public static Computer getComputer(ComputerAbstractFactory factory){
				return factory.createComputer();
			}
		}
		Computer myPC = ComputerFactory.getComputer(new PCFactory(".."..".."))
		Computer myServer = ComputerFactory.getComputer(new ServerFactory(".."..".."))

	_KOTLIN_

		// For the same; PC, Server and Computer classes stay the same.
		public interface ComputerAbstractFactory{
    		abstract fun createComputer(): Computer
		}
		public class PCFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
			override fun createComputer(): Computer = PC(ram, hdd, cpu)
		}
		public class ServerFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
			override fun createComputer(): Computer = Server(ram, hdd, cpu)
		}
		public class ComputerFactory{
			companion object{
				public fun getComputer(computerAbstractFactory: ComputerAbstractFactory): Computer{
					return computerAbstractFactory.createComputer()
				}
			}
		}

# BUILDER PATTERN #

	Builder pattern solves some of the problems with Factory and Abstract Factory
	design patterns when creating the object contains a lot of attributes. Builder
	pattern solves the issue with large number of optional parameters by providing
	a way to build the object step-by-step and provide a method that will return the
	final object.

	_JAVA_

		public class Computer{
			// Required parameters.
			private String HDD;
			private String RAM;
			// Optional parameters.
			private boolean isGraphicCardEnabled;
			private boolean isBluetoothEnabled;

			// Getters of all members...

			// Contructor is private to prevent object creating directly.
			private Computer(ComputerBuilder builder){
				this.HDD = builder.HDD;
				this.RAM = builder.RAM;
				this.isGraphicCardEnabled = builder.isGraphicCardEnabled;
				this.isBluetoothEnabled = builder.isBluetoothEnabled;
			}

			// A Computer object can be created by using ComputerBuilder class and its functions.
			public static class ComputerBuilder{
				// Required parameters.
				private String HDD;
				private String RAM;
				// Optional parameters.
				private boolean isGraphicCardEnabled;
				private boolean isBluetoothEnabled;

				// Required parameters will be given by this contructor.
				public ComputerBuilder(String HDD, String RAM){
					this.HDD = HDD;
					this.RAM = RAM;
				}

				// By "return this", client can call these setter methods consecutively.
				public ComputerBuilder setGraphicCardEnabled(boolean isGraphicCardEnabled){
					this.isGraphicCardEnabled = isGraphicCardEnabled;
					return this;
				}
				public ComputerBuilder setBluetoothEnabled(boolean isBluetoothEnabled){
					this.isBluetoothEnabled = isBluetoothEnabled;
					return this;
				}
				// Finished the building process and returns the final Computer object.
				public Computer build(){
					return new Computer(this);
				}
			}
		}

		// In Main function.
		Computer computer = ComputerBuilder("HDD", "RAM").
								setBluetoothEnabled(true).
								setGraphicCardEnabled(false).
								build();

	_KOTLIN_

		In kotlin, you can use "apply" keyword or default "named" parameters.
