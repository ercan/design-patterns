# CREATIONAL DESIGN PATTERNS #
	
	Creational design patterns provide solution to instantiate an object in the best possible way for
	specific situations.

	# SINGLETON PATTERN #

		Singleton pattern restricts the instantiation of a class and ensures that
		only one instance of the class exists in JVM.

		- Private Constructor to restrict instantiation of the class from other classes.
		- Private static variable of the same class that is the only instance of the class.
		- Public static method that returns the instance of the class, this is the global
			access point for outer world to get instance of the singleton class.

		_JAVA_

			public class SingletonClass{

				private static SingletonClass instance;

				private SingletonClass(){}

				// "synchronized" keyword ensures that only one thread can call 
				// the getInstance method at the same time.
				public static synchronized SingletonClass getInstance(){
					if(instance == null)
						instance = new SingletonClass();
					return instance;
				}
			}

		_KOTLIN_

			// Singleton object can inherit another class.
			object Singleton{
				init {
					println("Singleton class invoked.")
				}
				// Variables and functions in this scope are "static" member of the Singleton object.
				// Functions can take parameters and return objects.
				var variableName = "I am Var"
				fun printVarName(){
					println(variableName)
				}
			}

	# FACTORY PATTERN #

		Factory pattern is used when we have a super class with multiple sub-classes
		and based on input, we need to return one of the sub-class. We can apply Singleton
		pattern on Factory class or make the factory method static.

		_JAVA_

			public abstract class Computer {
		
				public abstract String getRAM();
				public abstract String getHDD();
				public abstract String getCPU();
				
				@Override
				public String toString(){
					return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU();
				}
			}

			public class PC extends Computer {

				private String ram;
				private String hdd;
				private String cpu;
		
				public PC(String ram, String hdd, String cpu){
					this.ram=ram;
					this.hdd=hdd;
					this.cpu=cpu;
				}
				// getters & setters
			}

			public class Server extends Computer {
			
				private String ram;
				private String hdd;
				private String cpu;
		
				public Server(String ram, String hdd, String cpu){
				this.ram=ram;
				this.hdd=hdd;
				this.cpu=cpu;
				}
				// getters & setters
			}

			// getComputer method is the factory method that returns a Computer according to parameters.
			public class ComputerFactory {

				public static Computer getComputer(String type, String ram, String hdd, String cpu){
					if("PC".equalsIgnoreCase(type)) 
						return new PC(ram, hdd, cpu);
					else if("Server".equalsIgnoreCase(type)) 
						return new Server(ram, hdd, cpu);
					return null;
				}
			}

		_KOTLIN_

			abstract class Computer{
				abstract fun getRAM(): String
				abstract fun getHDD(): String
				abstract fun getCPU(): String

				override fun toString(): String{
					return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU()
				}
			}

			public class PC (var ram: String, var hdd: String, var cpu: String) : Computer(){
				override fun getRAM(): String{
					return ram
				}
				override fun getHDD(): String{
					return hdd
				}
				override fun getCPU(): String{
					return this.cpu
				}
				// and setters...
			}

			public class Server (var ram: String, var hdd: String, var cpu: String) : Computer(){
				override fun getRAM(): String{
					return ram
				}
				override fun getHDD(): String{
					return hdd
				}
				override fun getCPU(): String{
					return this.cpu
				}
				// and setters...
			}

			public class ComputerFactory{
				companion object{
					public fun getComputer(type: String, ram: String, hdd: String, cpu: String): Computer? = 
						when(type){
							"PC" -> PC(ram, hdd, cpu)
							"SERVER" -> Server(ram, hdd, cpu)
							else -> null
						}
				}
			}

	# ABSTRACT FACTORY PATTERN #

		Abstract factory pattern is similar to Factory pattern but we get rid of if-else or when block
		in abstract factory pattern and we have a factory class for each sub-class. It is called 
		"the factory of factories".

		_JAVA_
			// For the same; PC, Server and Computer classes stay the same.
			public interface ComputerAbstractFactory {
				public Computer createComputer();
			}
			public class ComputerFactory {
				public static Computer getComputer(ComputerAbstractFactory factory){
					return factory.createComputer();
				}
			}
			Computer myPC = ComputerFactory.getComputer(new PCFactory(".."..".."))
			Computer myServer = ComputerFactory.getComputer(new ServerFactory(".."..".."))

		_KOTLIN_

			// For the same; PC, Server and Computer classes stay the same.
			public interface ComputerAbstractFactory{
				abstract fun createComputer(): Computer
			}
			public class PCFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
				override fun createComputer(): Computer = PC(ram, hdd, cpu)
			}
			public class ServerFactory (private var ram: String, private var hdd: String, private var cpu: String) : ComputerAbstractFactory{
				override fun createComputer(): Computer = Server(ram, hdd, cpu)
			}
			public class ComputerFactory{
				companion object{
					public fun getComputer(computerAbstractFactory: ComputerAbstractFactory): Computer{
						return computerAbstractFactory.createComputer()
					}
				}
			}

	# BUILDER PATTERN #

		Builder pattern solves some of the problems with Factory and Abstract Factory
		design patterns when creating the object contains a lot of attributes. Builder
		pattern solves the issue with large number of optional parameters by providing
		a way to build the object step-by-step and provide a method that will return the
		final object.

		_JAVA_

			public class Computer{
				// Required parameters.
				private String HDD;
				private String RAM;
				// Optional parameters.
				private boolean isGraphicCardEnabled;
				private boolean isBluetoothEnabled;

				// Getters of all members...

				// Contructor is private to prevent object creating directly.
				private Computer(ComputerBuilder builder){
					this.HDD = builder.HDD;
					this.RAM = builder.RAM;
					this.isGraphicCardEnabled = builder.isGraphicCardEnabled;
					this.isBluetoothEnabled = builder.isBluetoothEnabled;
				}

				// A Computer object can be created by using ComputerBuilder class and its functions.
				public static class ComputerBuilder{
					// Required parameters.
					private String HDD;
					private String RAM;
					// Optional parameters.
					private boolean isGraphicCardEnabled;
					private boolean isBluetoothEnabled;

					// Required parameters will be given by this contructor.
					public ComputerBuilder(String HDD, String RAM){
						this.HDD = HDD;
						this.RAM = RAM;
					}

					// By "return this", client can call these setter methods consecutively.
					public ComputerBuilder setGraphicCardEnabled(boolean isGraphicCardEnabled){
						this.isGraphicCardEnabled = isGraphicCardEnabled;
						return this;
					}
					public ComputerBuilder setBluetoothEnabled(boolean isBluetoothEnabled){
						this.isBluetoothEnabled = isBluetoothEnabled;
						return this;
					}
					// Finished the building process and returns the final Computer object.
					public Computer build(){
						return new Computer(this);
					}
				}
			}

			// In Main function.
			Computer computer = ComputerBuilder("HDD", "RAM").
									setBluetoothEnabled(true).
									setGraphicCardEnabled(false).
									build();

		_KOTLIN_

			In kotlin, you can use "apply" keyword or default "named" parameters.

	# PROTOTYPE PATTERN #

		Prototype pattern is used when the object creation requires a lot of time and resources and you
		have similar object already existing. So this pattern provides a mechanism to copy the original
		object to a new object and modify it according to our needs.

# STRUCTURAL DESIGN PATTERNS #

	Structural design patterns provide different ways to organize class structure. This "class structure" 
	may refer one or more classes.

	# ADAPTER PATTERN #

		Adapter pattern is used so that two unrelated interfaces can work together. The object that joins
		these unrelated interfaces is called an "Adapter". 

		_JAVA_

			// MPH to KMPH adapter.

			public interface Movable{
				double getSpeed();
			}
			public class BugattiVeyron implements Movable{
				@Override
				public double getSpeed(){
					// 268 MPH.
					return 268;
				}
			}
			public interface MovableAdapter{
				double getSpeed();
			}
			public class MovableAdapterImpl implements MovableAdapter{
				private Movable luxuryCar;
				
				MovableAdapterImpl(Movable luxuryCar){
					this.luxuryCar = luxuryCar;
				}

				@Override
				public double getSpeed(){
					return convertMPHtoKMPH(luxuryCar.getSpeed());
				}

				private convertMPHtoKMPH(double mph){
					return mph * 1.609.35
				}
			}

			// In test.
			Movable bugattiVeyron = new BugattiVeyron();
			MovableAdapter bugattiVeyronAdapter = new MovableAdapterImpl(bugattiVeyron);
			// This prints 431.30312 as KMPH.
			System.out.println(bugattiVeyronAdapter.getSpeed());

	# COMPOSITE PATTERN #

		Composite design pattern is used when we have to represent a part-whole hierarchy or when we need to
		create a structure in a way that the objects in the structure have to be treated the same way. Composite
		pattern consists of 3 objects.

		1) BASE COMPONENT	:	is the interface for all objects in the composition, client program uses base
								component to work with the all objets in the composition. This defines common
								methods for leafs and composites.

		2) LEAF				:	defines the behaviour for the elements in the composition. It is the building
								block for the composition and implements base component. It does not have
								references to other components.

		3) COMPOSITE		:	consists of leaf elements and implements the operations in base component.

		_JAVA_

			// This is the "Base Component" of the composition.
			public interface Shape {
				public void draw(String fillColor);
			}

			// The "Triangle" and "Circle" classes are the "Leafs" in the composition. 
			public class Triangle implements Shape{
				@Override
				public void draw(String fillColor){
					System.out.println("Drawing Triangle with color "+fillColor);
				}
			}
			public class Circle implements Shape {
				@Override
				public void draw(String fillColor) {
					System.out.println("Drawing Circle with color "+fillColor);
				}
			}

			// This "Drawin" class is a "Composite" in the composition which contains leafs and operate on them.
			public class Drawing implements Shape{

				//collection of Shapes
				private List<Shape> shapes = new ArrayList<Shape>();
				
				@Override
				public void draw(String fillColor) {
					for(Shape sh : shapes){
						sh.draw(fillColor);
					}
				}
				
				//adding shape to drawing
				public void add(Shape s){
					this.shapes.add(s);
				}
				
				//removing shape from drawing
				public void remove(Shape s){
					shapes.remove(s);
				}
				
				//removing all the shapes
				public void clear(){
					System.out.println("Clearing all the shapes from drawing");
					this.shapes.clear();
				}
			}

	# PROXY PATTERN #

		Proxy pattern is used when we want to provide controlled access of a functionality. This provides a
		surrogate for another object to control access to it.

		_JAVA_

			public interface CommandExecutor{
				public void runCommand(String cmd) throws Exception;
			}

			public class CommandExecutorImpl implements CommandExecutor{
				@Override
				public void runCommand(String cmd) throws IOException{
					Runtime.getRuntime().exec(cmd);
				}
			}

			// Now we want to provide only admin users to have full access of above class. If the user is not
			// admin then only limited commands will be allowed. For example below, we are restricting the use
			// of "rm" command by using a proxy class.
			public class CommandExecutorProxy implements CommandExecutor{
				private boolean isAdmin;
				private CommandExecutor executor;

				public CommandExecutorProxy(String userName, String password){
					// Check if the user is an admin or not by using IF block(s).
				}
				@Override
				public void runCommand(String cmd) throws IOException{
					if(isAdmin){
						executor.runCommand(cmd);
					}
					else{
						if(cmd.trim().startsWith("rm"))
							throw new Exception("run command is not allowed for non-admin users");
						else
							executor.runCommand(cmd);
					}
				}
			}

			// In main function
			// "ls" command will work but "rm -rf" command will not.
			CommandExecutor executor = new CommandExecutorProxy("Ercan", "myPassword");
			try{
				executor.runCommand("ls -all");
				executor.runCommand("rm -rf *");
			}
			catch(Exception e){
				System.out.println("EXCEPTION MESSAGE: " + e.getMessage());
			}

	# FLYWEIGHT PATTERN #

		Flyweight design pattern is used when we need to create a lot of objects of a class. To consume the 
		system resources efficiently, we can use flyweight design pattern by sharing objects. Before applying
		flyweight pattern, we need to consider some factors:

		1)	The number of the objects to be created should be huge.
		2)	The object creation should be time consuming and heavy on memory.
		3)	The object properties should be divided into intrinsic and extrinsic properties. Extrinsic properties
			is defined by the client program.

		Intrinsic properties make the object unique whereas extrinsic properties are set by the client code and
		used to perform different operations. For example, a circle object can have extrinsic properties such as
		color and width.

		_JAVA_

			public interface Shape{
				public draw(Graphics g, int x, int y, int width, int height, Color color);
			}
			public class Lines implements Shape{
				public Line(){
					// Creating line object.
				}
				@Override
				public void draw(Graphics line, int x1, int y1, int x2, int y2, Color color){
					line.setColor(color);
					line.drawLine(x1, y1, x2, y2);
				}
			}
			public class Oval implements Shape{

				// Instrinsic propert.
				private boolean fill;

				public Oval(boolean f){
					this.fill = f;
					// Creating oval object.
				}
				@Override
				public void draw(Graphics circle, int x, int y, int width, int height, Color color){
					circle.setColor(color);
					circle.drawOval(x, y, width, height);
					if(fill)
						circle.fillOval(x, y, width, height);
				}
			}

			// Whenever client program makes a call to get an instance of Object, it should be returned from 
			// the HashMap, if not found then create a new Object and put in the Map and then return it. 
			// We need to make sure that all the intrinsic properties are considered while creating the Object.

			// Flyweight Factory Class.
			public class ShapeFactory{
				private static final HashMap<ShapeType, Shape> shapes = new HashMap<ShapeType, Shape>();

				public static Shape getShape(ShapeType type){
					Shape shapeImpl = shapes.get(type);
					if (shapeImpl == null){
						if (type.equals(ShapeType.OVAL_FILL))
							shapeImpl = new Oval(true);
						else if (type.equals(ShapeType.OVAL_NOFILL))
							shapeImp = new Oval(false);
						else if (type.equals(ShapeType.LINE))
							shapeImp = new Line();

						shapes.put(type, shapeImpl);
					}
					return shapeImpl;
				}

				public static enum ShapeType{
					OVAL_FILL, 
					OVAL_NOFILL, 
					LINE;
				}
			}

	# FACADE PATTERN #

		Facade pattern is used to help clients to easily interacy with the system. Suppose we have an 
		application with a set of interfaces to use MySql/Oracle database and to generate different types
		of reports, such as html or pdf report etc. So we will have a different set of interfaces to work
		with different types of database. Now a client application can use these interfaces to get the required
		database connection and generate reports. But if the complexity increases then the client application
		will find it difficult to manage it. So we can apply Facade pattern here and provide a wrapper interface
		on top of the existing interface. According to GoF, facade pattern defines a higher-level interface
		that makes the subsystem easier to use. Facade design pattern can be applied at any point of development, 
		usually when the number of interfaces grow and system gets complex. Subsystem interfaces are not aware of 
		Facade and they shouldn’t have any reference of the Facade interface.

		_JAVA_

			public class MySqlHelper{
				public static Connection getMySqlDBConnection(){
					//...
					return null;
				}
				public void generateMySqlPDFReport(String tableName, Connection con){
					//...
				}
				public void generateMySqlHTMLReport(String tableName, Connection con){
					//...
				}
			}
			public class OracleHelper{
				public static Connection getOracleDBConnection(){
					//...
					return null;
				}
				public void generateOraclePDFReport(String tableName, Connection con){
					//...
				}
				public void generateOracleHTMLReport(String tableName, Connection con){
					//...
				}
			}

			// Now this is facade pattern interface.
			public class DBHelperFacade{
				public static void generateReport(DBTypes dbType, ReportTypes reportType, String table){
					// By checking enum values, the appropriate report can be generated.
				}

				public static enum DBTypes{
					MYSQL,
					ORACLE;
				}
				public static enum ReportTypes{
					HTML,
					PDF;
				}
			}

	# BRIDGE PATTERN #

		The Bridge design pattern allows you to separate the abstraction from the implementation.It is 
		a structural design pattern. There are 2 parts in Bridge design pattern:

		1) Abstraction
		2) Implementation

		_JAVA_

			// abstraction in bridge pattern 
			abstract class Vehicle { 
				protected Workshop workShop1; 
				protected Workshop workShop2; 

				protected Vehicle(Workshop workShop1, Workshop workShop2) 
				{ 
					this.workShop1 = workShop1; 
					this.workShop2 = workShop2; 
				} 

				abstract public void manufacture(); 
			} 

			// Refine abstraction 1 in bridge pattern 
			class Car extends Vehicle { 
				public Car(Workshop workShop1, Workshop workShop2) 
				{ 
					super(workShop1, workShop2); 
				} 

				@Override
				public void manufacture() 
				{ 
					System.out.print("Car "); 
					workShop1.work(); 
					workShop2.work(); 
				} 
			} 

			// Refine abstraction 2 in bridge pattern 
			class Bike extends Vehicle { 
				public Bike(Workshop workShop1, Workshop workShop2) 
				{ 
					super(workShop1, workShop2); 
				} 

				@Override
				public void manufacture() 
				{ 
					System.out.print("Bike "); 
					workShop1.work(); 
					workShop2.work(); 
				} 
			} 

			// Implementor for bridge pattern 
			interface Workshop 
			{ 
				abstract public void work(); 
			} 

			// Concrete implementation 1 for bridge pattern 
			class Produce implements Workshop { 
				@Override
				public void work() 
				{ 
					System.out.print("Produced"); 
				} 
			} 

			// Concrete implementation 2 for bridge pattern 
			class Assemble implements Workshop { 
				@Override
				public void work() 
				{ 
					System.out.print(" And"); 
					System.out.println(" Assembled."); 
				} 
			} 

			// Demonstration of bridge design pattern 
			class BridgePattern { 
				public static void main(String[] args) 
				{ 
					Vehicle vehicle1 = new Car(new Produce(), new Assemble()); 
					vehicle1.manufacture(); 
					Vehicle vehicle2 = new Bike(new Produce(), new Assemble()); 
					vehicle2.manufacture(); 
				} 
			} 

	# DECORATOR PATTERN #

		The decorator design pattern is used to modify the functionality of an object at runtime. At the same
		time, other instances of the same class wil not be affected by this. Lets say that we have a "Car"
		interface, "BasicCar" class which implements "Car", "SportsCar" and "LuxuryCar" classes which extends 
		"BasicCar" class. But what if we want to get a car at runtime that has both the features of sports car
		and luxury car? Then the implementation would get complext by using inheritance and composition. Therefor
		we need decorator design pattern.

		_JAVA_

			// Component interface.
			public interface Car{
				public void assembe();
			}
			// Component implementation.
			public class BasicCar implements Car{
				@Override
				public void assemble(){
					//...
				}
			}
			// Decorator class implements the component interface and it has a HAS-A relationship with the
			// component interface.
			public class CarDecorator implements Car{
				protected Car car;

				public CarDecorator(Car c){
					this.car = c;
				}

				@Override
				public void assemble(){
					this.car.assemble();
				}
			}
			// Concrete Decorators extending the base decorator functionality and modifying the component
			// behaviour accordingly.
			public class SportsCar extends CarDecorator{
				public SportsCar(Car c){
					super(c);
				}

				@Override
				public void assemble(){
					super.assemble();
					//...
				}
			}
			public class LuxuryCar extends CarDecorator{
				public LuxuryCar(Car c){
					super(c);
				}

				@Override
				public void assemble(){
					super.assemble();
					//...
				}
			}

			// main function

			Car sportsCar = new SportsCar(new BasicCar());
			sportsCar.assemble();

			Car sportsLuxuryCar = new SportsCar(new LuxuryCar(new BasicCar()));
			sportsLuxuryCar.assemble();

# BEHAVIOURAL DESIGN PATTERNS #

	Behavioral patterns provide solutions for the better interaction between objects.

	# TEMPLATE METHOD PATTERN #

		Template method defines the steps to execute an algorithm and it can provide a default implementation
		that might be common for all or some of the subclasses. Suppose we want to provide an algorithm to build
		a house. The steps are building a foundation, building pillars, building walls and windows. We can not
		change this order of execution.

		_JAVA_

			public abstract class HouseTemplate{
				
				// The Template Method. This is final so subclasses can not override.
				public final void buildHouse(){
					buildFoundation();
					buildPillars();
					buildWalls();
					buildWindows();
					System.out.println("House is built.");
				}

				// Default implementations.
				private void buildFoundation(){
					System.out.println("Building Foundation...");
				}
				private void buildWindows(){
					System.out.println("Building Glass Window...");
				}

				// Methods to be implemented by subclasses.
				public abstract void buildWalls();
				public abstract void buildPillars();				
			}

			// Different type of houses.
			public class WoodenHouse extends HouseTemplate {

				@Override
				public void buildWalls() {
					System.out.println("Building Wooden Walls");
				}

				@Override
				public void buildPillars() {
					System.out.println("Building Pillars with Wood coating");
				}
			}
			public class GlassHouse extends HouseTemplate {

				@Override
				public void buildWalls() {
					System.out.println("Building Glass Walls");
				}

				@Override
				public void buildPillars() {
					System.out.println("Building Pillars with glass coating");
				}
			}

	# MEDIATOR PATTERN #

		Mediator design pattern is used to pfovide a centraliszed communication medium between different objects
		in a system. If the objects interact with each other directly, the system components are tightly coupled 
		with eac other that makes maintainability cost higher and not flexible to extend easily. The mediator
		works as a router between objects and it can have its owns logic to provide a way of communicatin. An
		airport control room can be given as an example.

		// Mediator Interface.
		public interface ChatMediator{
			public void sendMessage(String msg, User user);
			void addUser(User user);
		}

		// Users can send and receive messages.
		public abstract class User{
			protected ChatMediator mediator;
			protected String name;

			public User(ChatMediator mediator, String name){
				this.mediator = mediator;
				this.name = name;
			}

			public abstract void send(String msg);
			public abstract void receive(String msg);
		}

		// Concrete Mediator.
		public class ChatMediatorImpl implements ChatMediator{

			private List<User> users;
			public ChatMediatorImpl(){
				this.users = new ArrayList<>();
			}

			@Override
			public void addUser(User user){
				this.users.add(user);
			}

			@Override
			public void sendMessage(String msg, User user){
				for(User u : users){
					// The message should not be received by the user sending it.
					if(u != user)
						u.receive(msg);
				}
			}
		}

		// Concreate Colleague. Colleagues are the users of mediator.
		public class UserImpl extends User{
			public UserImpl(ChatMediator mediator, String name){
				super(mediator, name);
			}
			@Override
			public void send(String msg){
				mediator.sendMessage(msg, this);
			}
			@Override
			public void receive(String msg){
				System.out.println("Message received is " + msg);
			}
		}

		// in main function.
		ChatMediator mediator = new ChatMediatorImpl();
		User user1 = new UserImpl(mediator, "Pankaj");
		User user2 = new UserImpl(mediator, "Lisa");
		User user3 = new UserImpl(mediator, "Saurabh");
		User user4 = new UserImpl(mediator, "David");
		mediator.addUser(user1);
		mediator.addUser(user2);
		mediator.addUser(user3);
		mediator.addUser(user4);
		user1.send("Hi All");

	# CHAIN OF RESPONSIBILITY PATTERN #

		CoR pattern is used to achieve loose coupling in software design where a request from the client is
		passed to a chain of objects to process them. Then the object in the chain will decide themselves who
		will be processing the request and whether the request is required to be send to the next object in the
		chain or not. Every object in the chain should have reference to the next object in chain to forward the 
		request to, its achieved by java composition This is an ATM Dispense example:

		_JAVA_

			public class Currency{
				private int amount;

				public Currency(int amt){
					this.amount = amt;
				}

				public int getAmount(){
					return this.amount;
				}
			}

			public interface DispenseChain{
				void setNextChain(DispenseChain nextChain);
				void dispense(Currency cur);
			}

			public class Dollar50Dispenser implements DispenseChain{
				private DispenseChain chain;

				@Override
				public void setNextChain(DispenseChain nextChain){
					this.chain = nextChain;
				}

				@Override
				public void dispense(Currency cur){
					if(cur.getAmount() >= 50){
						int num = cur.getAmount() / 50;
						int remainder = cur.getAmount() % 50;
						System.out.println("Dispensing "+num+" 50$ note");
						if(remainder != 0)
							this.chain.dispense(new Currency(remainder));
					}
					else{
						this.chain.dispense(cur);
					}
				}
			}
			public class Dollar20Dispenser implements DispenseChain{
				private DispenseChain chain;
				
				@Override
				public void setNextChain(DispenseChain nextChain) {
					this.chain=nextChain;
				}

				@Override
				public void dispense(Currency cur) {
					if(cur.getAmount() >= 20){
						int num = cur.getAmount()/20;
						int remainder = cur.getAmount() % 20;
						System.out.println("Dispensing "+num+" 20$ note");
						if(remainder !=0) this.chain.dispense(new Currency(remainder));
					}else{
						this.chain.dispense(cur);
					}
				}
			}
			public class Dollar10Dispenser implements DispenseChain {
				private DispenseChain chain;
				
				@Override
				public void setNextChain(DispenseChain nextChain) {
					this.chain=nextChain;
				}

				@Override
				public void dispense(Currency cur) {
					if(cur.getAmount() >= 10){
						int num = cur.getAmount()/10;
						int remainder = cur.getAmount() % 10;
						System.out.println("Dispensing "+num+" 10$ note");
						if(remainder !=0) this.chain.dispense(new Currency(remainder));
					}else{
						this.chain.dispense(cur);
					}
				}
			}

			// Test
			public class ATMDispenseChain{
				private DispenseChain c1;
				public ATMDispenseChain(){
					this.c1 = new Dollar50Dispenser();
					DispenseChain c2 = new Dollar20Dispenser();
					DispenseChain c3 = new Dollar10Dispenser();

					c1.setNextChain(c2);
					c2.setNextChain(c3);
				}

				public static void main(String[] args) {
					ATMDispenseChain atmDispenser = new ATMDispenseChain();

					while (true) {
						int amount = 0;
						System.out.println("Enter amount to dispense");
						Scanner input = new Scanner(System.in);
						amount = input.nextInt();
						if (amount % 10 != 0) {
							System.out.println("Amount should be in multiple of 10s.");
							break;
						}
						// Process the request
						atmDispenser.c1.dispense(new Currency(amount));
					}
				}
			}